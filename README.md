# Xpath
## Узлы
Всего в XPath выделяется семь типов узлов: `элемент`, `атрибут`, `текст`, `пространство имен`, `инструкция обработки`, `комментарий и узлы документа`.


## Выбор узлов
* '/'	- Выбирает от корневого узла
* '//' - Выбирает узлы от текущего узла, соответствующего выбору, независимо от их местонахождения
* '.' - Выбирает текущий узел
* '..' - Выбирает родителя текущего узла
* '@' - Выбирает атрибуты

## Предикаты
Предикаты всегда заключаются в квадратные скобки.
* `/messages/note[last()]`	Выбирает последний элемент note, который является прямым потомком элемента messages.
* `/messages/note[last()-1]`	Выбирает предпоследний элемент note, который является прямым потомком элемента messages.
* `/messages/note[position()<3]`	Выбирает первые два элемента note, которые являются прямыми потомками элемента messages.

## Выбор неизвестных заранее узлов
Чтобы найти неизвестные заранее узлы XML документа, XPath позволяет использовать специальные символы.
* `*`	Соответствует любому узлу элемента
* `@*`	Соответствует любому узлу атрибута
* `node()`	Соответствует любому узлу любого типа

## Выбор нескольких путей
* `//note/heading | //note/body`	Выбирает все элементы heading И body из всех элементов note
* `//heading | //body`	Выбирает все элементы heading И body во всем документе

## Оси XPath
Ось определяет отношение узлового набора по отношению к текущему узлу.
* `ancestor`	Выбирает всех предков текущего узла
* `ancestor-or-self`	Выбирает всех предков текущего узла и сам текущий узел
* `attribute`	Выбирает все атрибуты текущего узла
* `child`	Выбирает всех прямых потомков текущего узла
* `descendant`	Выбирает всех потомков текущего узла
* `descendant-or-self`	Выбирает всех потомков текущего узла и сам текущий узел
* `following`	Выбирает все элементы в документе после закрывающего тега текущего узла
* `following-sibling`	Выбирает все элементы одного уровня после текущего узла
* `namespace`	Выбирает все узлы пространства имен текущего узла
* `parent`	Выбирает родителя текущего узла
* `preceding`	Выбирает все узлы, которые появляются перед текущим узлом, за исключением предков, узлов атрибутов и пространства имен
* `preceding-sibling`	Выбирает все элементы одного уровня до текущего узла
* `self`	Выбирает текущий узел

Для наиболее часто используемых осей существуют сокращения:
* `attribute::` – можно заменить на "`@`";
* `child::` – часто просто опускают;
* `descendant::` – можно заменить на "`.//`";
* `parent::` – можно заменить на "`..`";
* `self::` – можно заменить на "`.`".

### Примеры
* `child::note`	Выбирает все узлы note, которые являются прямыми потомками текущего узла
* `attribute::date`	Выбирает атрибут date текущего узла
* `child::*`	Выбирает всех прямых потомков текущего узла
* `attribute::*`	Выбирает все атрибуты текущего узла
* `child::text()`	Выбирает все текстовые узлы текущего узла
* `child::node()`	Выбирает всех прямых потомков текущего узла
* `descendant::note`	Выбирает всех потомков note текущего узла
* `ancestor::note`	Выбирает всех предков note текущего узла
* `ancestor-or-self::note`	Выбирает всех предков note текущего узла, а также сам текущий узел, если это узел note
* `child::*/child::heading`	Выбирает всех прямых потомков прямых потомков ("внуков") heading текущего узла

## Операторы XPath
Оператор	Описание	Пример
* `|`	Обрабатывает два узловых набора	`//note | //cd`
* `+`	Сложение	`5 + 7`
* `-`	Вычитание	`7 - 5`
* `*`	Умножение	`9 * 5`
* `div`	Деление	`4 div 3`
* `=`	Равно	`lang=6.90`
* `!=`	Не равно	`lang!=4.50`
* `<`	Меньше	`ret<7.10`
* `<=`	Меньше или равно	`terra<=9.80`
* `>`	Больше	`root>2.55`
* `>=`	Больше или равно	`last>=4.30`
* `or`	Или	`step=10 or loop=7.70`
* `and`	И	`loop>6.00 and loop`
* `mod`	Остаток от деления	`5 mod 2`

## Полезное

* `contains` -- содержит (atr, 'T' // пробел)
* `not contains` -- не содержит 
* `/` - следующий тег
* `//` - следующий тег с возможностью пропуска предыдущих
* `ancestor` - взять то что сверху
* `../` - подняться на 1 элемент(к родителю) (/../)
* `last()` - последний элемент
* `text()` - поиск по тексту
* `*` - найдет все
* `starts-with` – возвращает элементы, поля которых начинаются с искомой последовательности символов
* `sibling` – возвращает сестринский элемент – элемент, который расположен на том же уровне, что и начальный (не потомок и не предок). Выделяют 2 типа:
* `preceding-sibling`  –  сестринский  элемент,  который  расположен  до (выше) указанного
* `following-sibling`   –   сестринский   элемент,   расположенный   после (ниже) указанного.

## Примеры:
> teg = t
> atribute = atr
> заголовок = Z
> текст = T

* `//t[@atr='Z']`
* `//t[@atr='Z'][@atr='Z'] or t[@atr='xxx' and @atr='Z']`
* `//t[contains(@atr, 'T')]`
* `//t[contains(@atr, 'T')][contains(@, 'T')]`
* `//t[contains(@atr, 'T')][contains(@, 'T')]`
* `//t[contains(@atr, 'T')][not(contains(@, 'T'))]`
* `//t[@art='T']/t2` - спустится по дереву вниз (t2 - ребенок t)
* `//t[@atr='Z']/ancestor::t3` - подняться по дереву вверх (t3 - родитель t)
* `//t[@atr='T']/../..t2[not(@t3='T3')]`
* `//t[@atr='T1'] or @atr='T2' or @atr='T3'` - коллекция по атрибуту
* `//t[@atr='T']//t2[last()]` - последний элемент из коллекции `//t[@atr='T']//t2`
* `//t[@atr='T']//t2[last()-1]` - пред последний элемент из коллекции //t[@atr='T']//t2
* `//t[@atr!=T]` - найдем элемент который не атрибут не равен тексту(например 5) либо <,> <= и тд
* `//t[@atr>=T and @atr<=T2]`
* `//t[text()='T']`
* `//t[contains(text(), 'частьT')]`
* `//t[contains(text(), 'частьT')][not(conteins(text(),'T2'))]`
* `//*[@atr='T']`
* `//teg[@atr='T'][contains(@, 'T')]`

### XPath еще

- `//` - Хороший XPath всегда должен начинаться с двух //
- `text()` - Поиск по тексту
- `@class` - Поиск по классу
- `@attribute` - Поиск по аттрибуту
- `contains` - что-то содержит
- `starts-with` - начинается с ...
- `/preceding-sibling::` - поиск сестринского элемента, который находится выше
- `/following-sibling::` - поиск сестринского который находится снизу
- `/parent::` - поиск родительского элемента
- `/ancestor::` - поиск дальнего предка (дедушки, прадедушки)
- `/child::` - поиск дочернего элемента
- `/` - тоже самое что и /child::
- `/descendant::` - поиск дальнего потомка (внучка, правнука)
- `//` - тоже самое что и /descendant::


CCS
* `div` - ищем по тегу
* `.input-search` - ищем по классу
* `#username` - ищем по id
* `div >a` — ищем все a, у которых предок div
* `body[vlink=1]` — ищем тег боди, у котрого атрибут vlink=1
* `body[vlink*=1]` — ищем тег боди, у котрого атрибут vlink содержит в себе единичку
* `body[vlink^=1]` — ищем тег боди, у которого атрибут vlink начинается на единичку
* `body[vlink$=1]` — ищем тег боди, у которого атрибут vlink заканчивается на единичку
* `body button` - Пробел находит все потомков у элемента.



