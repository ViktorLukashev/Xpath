# Xpath

'/'	- Выбирает от корневого узла
'//' - Выбирает узлы от текущего узла, соответствующего выбору, независимо от их местонахождения
'.' - Выбирает текущий узел
'..' - Выбирает родителя текущего узла
'@' - Выбирает атрибуты

Предикаты











teg = t
atribute = atr
заголовок = Z
текст = T
contains -- содержит (atr, 'T' // пробел)
not contains -- не содержит 
/ - следующий тег
// - следующий тег с возможностью пропуска предыдущих
ancestor - взять то что сверху
../ - подняться на 1 элемент(к родителю) (/../)
last() - последний элемент
text() - поиск по тексту
* - найдет все
starts-with – возвращает элементы, поля которых начинаются с искомой последовательности символов
sibling – возвращает сестринский элемент – элемент, который расположен на том же уровне, что и начальный (не потомок и не предок). Выделяют 2 типа:
a.  preceding-sibling  –  сестринский  элемент,  который  расположен  до (выше) указанного
b.  following-sibling   –   сестринский   элемент,   расположенный   после (ниже) указанного.


//t[@atr='Z']
//t[@atr='Z'][@atr='Z'] or t[@atr='xxx' and @atr='Z']
//t[contains(@atr, 'T')]
//t[contains(@atr, 'T')][contains(@, 'T')] 
//t[contains(@atr, 'T')][contains(@, 'T')] 
//t[contains(@atr, 'T')][not(contains(@, 'T'))]
//t[@art='T']/t2 - спустится по дереву вниз (t2 - ребенок t)
//t[@atr='Z']/ancestor::t3 - подняться по дереву вверх (t3 - родитель t)
//t[@atr='T']/../..t2[not(@t3='T3')]
//t[@atr='T1'] or @atr='T2' or @atr='T3' - коллекция по атрибуту
//t[@atr='T']//t2[last()] - последний элемент из коллекции //t[@atr='T']//t2

//t[@atr='T']//t2[last()-1] - пред последний элемент из коллекции //t[@atr='T']//t2
//t[@atr!=T] - найдем элемент который не атрибут не равен тексту(например 5) либо <,> <= и тд
//t[@atr>=T and @atr<=T2]
//t[text()='T']
//t[contains(text(), 'частьT')]
//t[contains(text(), 'частьT')][not(conteins(text(),'T2'))]
//*[@atr='T']

//input[@class='text input__textfield text_type_main-default input__textfield-disabled'][contains(@, 'T')]

XPath

- // - Хороший XPath всегда должен начинаться с двух //

- text() - Поиск по тексту

- @class - Поиск по классу

- @attribute - Поиск по аттрибуту

- contains - что-то содержит

- starts-with - начинается с ...

- /preceding-sibling:: - поиск сестринского элемента, который находится выше

- /following-sibling:: - поиск сестринского который находится снизу

- /parent:: - поиск родительского элемента

- /ancestor:: - поиск дальнего предка (дедушки, прадедушки)

- /child:: - поиск дочернего элемента

- / - тоже самое что и /child::

- /descendant:: - поиск дальнего потомка (внучка, правнука)

- // - тоже самое что и /descendant::

Оси – это основа запросов XPath и их обязательная часть:         ancestor:: – возвращает множество предков;
* ancestor-or-self:: – возвращает множество предков и текущий элемент;         attribute:: – возвращает множество атрибутов текущего элемента;
* child:: – возвращает множество потомков на один уровень ниже;         descendant:: – возвращает полное множество потомков;
* descendant-or-self:: – возвращает полное множество потомков и текущий
элемент;
* following::  –  возвращает  необработанное  множество  элементов  ниже
текущего;
* following-sibling:: – возвращает множество элементов на том же уровне,
следующих за текущим;
* namespace::   –   возвращает   множество,   имеющее   пространство   имён (присутствует атрибут xmlns);
* parent:: – возвращает предка на один уровень назад;
* preceding:: – возвращает множество обработанных элементов, исключая
множество предков;
* preceding-sibling:: – возвращает множество элементов на том же уровне,
предшествующих текущему;
* self:: – возвращает текущий элемент.
Для наиболее часто используемых осей существуют сокращения: 
* attribute:: – можно заменить на "@";
* child:: – часто просто опускают;
* descendant:: – можно заменить на ".//";
* parent:: – можно заменить на "..";
* self:: – можно заменить на ".".


CCS

- div - ищем по тегу

- .input-search - ищем по классу

- #username - ищем по id

- div >a — ищем все a, у которых предок div

body[vlink=1] — ищем тег боди, у котрого атрибут vlink=1

body[vlink*=1] — ищем тег боди, у котрого атрибут vlink содержит в себе единичку

body[vlink^=1] — ищем тег боди, у которого атрибут vlink начинается на единичку

body[vlink$=1] — ищем тег боди, у которого атрибут vlink заканчивается на единичку

Пробел находит все потомков у элемента. Пример:

body button

